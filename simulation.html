<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Overfitting Simulator (Linear Regression with Polynomial Basis)</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #141a2d;
      --ink: #e9eefb;
      --muted: #aab2c8;
      --accent: #60a5fa;
      --accent-2: #34d399;
      --warn: #f59e0b;
      --grid: #27304a;
      --curve: #22c55e;
      --train: #60a5fa;
      --test: #f97316;
      --truth: #94a3b8;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--ink); background: radial-gradient(1200px 800px at 10% -10%, #1e2746 0%, var(--bg) 60%);
    }
    .page { max-width: 1100px; margin: 24px auto; padding: 0 16px 56px; }
    header { display: grid; gap: 8px; margin-bottom: 12px; }
    h1 { margin: 0; font-size: 28px; letter-spacing: 0.2px; }
    p.sub { margin: 0; color: var(--muted); }
    .panel { background: linear-gradient(180deg, #121a2b, #0e1424); border: 1px solid #1e2a48; border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.25); }

    .controls { display: grid; grid-template-columns: 1fr auto; gap: 16px; padding: 16px; align-items: center; border-bottom: 1px solid #1e2a48; }
    .controls .left { display: grid; gap: 8px; }

    .slider-row { display: grid; grid-template-columns: 160px 1fr 64px; gap: 12px; align-items: center; }
    .slider-row label { color: var(--muted); }
    input[type="range"] { width: 100%; }

    .buttons { display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap; }
    button { cursor: pointer; border: 1px solid #2a375e; background: #10192e; color: var(--ink); padding: 10px 14px; border-radius: 12px; font-weight: 600; letter-spacing: 0.2px; transition: transform .05s ease, border-color .2s ease, background .2s ease; }
    button:hover { border-color: #3b82f6; }
    button:active { transform: translateY(1px); }
    .primary { background: #102142; border-color: #3156a6; }

    .stats { display: grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 12px; padding: 12px 16px; border-bottom: 1px solid #1e2a48; }
    .stat { background: #0c1326; border: 1px solid #1c2646; border-radius: 12px; padding: 12px; display: grid; gap: 6px; }
    .stat small { color: var(--muted); }
    .stat .value { font-size: 20px; font-weight: 700; }
    .badge { display: inline-block; font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid #2a375e; color: var(--muted); }

    .plot-wrap { display: grid; grid-template-columns: 1fr; }
    .legend { display: flex; gap: 14px; padding: 12px 16px; color: var(--muted); border-top: 1px solid #0b1124; }
    .legend .item { display: flex; align-items: center; gap: 8px; }
    .swatch { width: 12px; height: 12px; border-radius: 3px; }
    .swatch.train { background: var(--train); }
    .swatch.test { background: var(--test); }
    .swatch.curve { background: var(--curve); }
    .swatch.truth { background: var(--truth); }

    canvas { width: 100%; height: 460px; display: block; }

    .footer { margin-top: 14px; color: var(--muted); font-size: 13px; }
    .note { color: var(--warn); }
    .muted { color: var(--muted); }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: #0b1120; padding: 2px 6px; border-radius: 6px; border: 1px solid #1e2a48; }

    @media (max-width: 760px) {
      .stats { grid-template-columns: 1fr; }
      .controls { grid-template-columns: 1fr; }
      .buttons { justify-content: stretch; }
      button { flex: 1 1 auto; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>Overfitting Simulator — Linear Regression with Polynomial Basis</h1>
      <p class="sub">Use the slider to adjust model complexity (polynomial degree). The model is estimated only on the training data. Click <span class="code">Reveal Test Set</span> to evaluate how well the model generalizes. Click <span class="code">Generate New Data</span> to refresh the dataset. Error metric: RMSE.</p>
    </header>

    <section class="panel">
      <div class="controls">
        <div class="left">
          <div class="slider-row">
            <label for="degree">Model complexity (degree):</label>
            <input id="degree" type="range" min="1" max="15" value="1" step="1" />
            <div id="degVal" class="badge">1</div>
          </div>
          <div class="muted">Data remain fixed when you move the slider. <em>Generate New Data</em> changes the train/test samples.</div>
        </div>
        <div class="buttons">
          <button id="revealBtn" class="primary">Reveal Test Set</button>
          <button id="regenBtn">Generate New Data</button>
        </div>
      </div>

      <div class="stats">
        <div class="stat">
          <small>Train RMSE</small>
          <div class="value" id="rmseTrain">—</div>
        </div>
        <div class="stat">
          <small>Test RMSE</small>
          <div class="value" id="rmseTest">Hidden</div>
        </div>
        <div class="stat">
          <small>Dataset</small>
          <div class="value"><span id="seedLabel">seed: —</span></div>
        </div>
      </div>

      <div class="plot-wrap">
        <canvas id="plot" width="1024" height="520" aria-label="Regression plot"></canvas>
        <div class="legend">
          <div class="item"><span class="swatch train"></span> Training points</div>
          <div class="item"><span class="swatch test"></span> Test points</div>
          <div class="item"><span class="swatch curve"></span> Learned model</div>
          <div class="item"><span class="swatch truth"></span> True function</div>
        </div>
      </div>
    </section>

    <p class="footer">
      <span class="note">Teaching tip:</span> Underfit appears at low degree (high bias), while high degrees can fit noise (low train error but worse test error). Because polynomial regression is linear in parameters, the normal equations solve it exactly for each degree.
    </p>
  </div>

  <script>
    // ===== Utilities: Seeded RNG, Stats, Linear Algebra =====
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    function randn(rng) { // Box-Muller
      let u = 0, v = 0; while (u === 0) u = rng(); while (v === 0) v = rng();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // Linear algebra helpers for small matrices
    function matMul(A, B) {
      const m = A.length, n = A[0].length, p = B[0].length;
      const C = Array.from({length: m}, () => Array(p).fill(0));
      for (let i = 0; i < m; i++) {
        for (let k = 0; k < n; k++) {
          const aik = A[i][k];
          for (let j = 0; j < p; j++) C[i][j] += aik * B[k][j];
        }
      }
      return C;
    }
    function matT(A) { const m = A.length, n = A[0].length; const AT = Array.from({length: n}, () => Array(m)); for (let i=0;i<m;i++){ for (let j=0;j<n;j++) AT[j][i]=A[i][j]; } return AT; }

    function matInv(A) { // Gauss-Jordan; for small dense matrices
      const n = A.length; const M = A.map((row,i)=> row.concat(Array.from({length:n}, (_,j)=> i===j?1:0)));
      // Partial pivoting
      for (let i = 0; i < n; i++) {
        // Find pivot
        let maxRow = i, maxVal = Math.abs(M[i][i]);
        for (let r = i+1; r < n; r++) { const v = Math.abs(M[r][i]); if (v > maxVal) { maxVal = v; maxRow = r; } }
        if (maxVal < 1e-12) throw new Error('Matrix is singular or ill-conditioned.');
        if (maxRow !== i) { const tmp = M[i]; M[i] = M[maxRow]; M[maxRow] = tmp; }
        // Normalize pivot row
        const piv = M[i][i]; for (let j = 0; j < 2*n; j++) M[i][j] /= piv;
        // Eliminate others
        for (let r = 0; r < n; r++) if (r !== i) {
          const f = M[r][i]; if (f === 0) continue; for (let j = 0; j < 2*n; j++) M[r][j] -= f * M[i][j];
        }
      }
      // Extract inverse
      return M.map(row => row.slice(n));
    }

    function polyFeatures(x, degree) {
      // x assumed in [-1,1] to improve conditioning
      const row = new Array(degree + 1);
      let p = 1; // x^0
      for (let d = 0; d <= degree; d++) { row[d] = p; p *= x; }
      return row;
    }

    function fitNormalEq(X, y) {
      // X: n x (d+1), y: n x 1 column vector
      const XT = matT(X);
      const XTX = matMul(XT, X);
      const XTy = matMul(XT, y);
      const XTX_inv = matInv(XTX);
      const theta = matMul(XTX_inv, XTy); // (d+1) x 1
      return theta.map(r => r[0]);
    }

    function predict(theta, x) {
      let y = 0, p = 1; // theta[0] + theta[1] x + ...
      for (let d = 0; d < theta.length; d++) { y += theta[d] * p; p *= x; }
      return y;
    }

    function rmse(yTrue, yPred) {
      const n = yTrue.length; let s = 0; for (let i=0;i<n;i++){ const e = yPred[i]-yTrue[i]; s += e*e; }
      return Math.sqrt(s / n);
    }

    // ===== Data generation =====
    const state = {
      degree: 1,
      reveal: false,
      seed: 12345,
      train: {x: [], y: []},
      test:  {x: [], y: []},
      theta: [],
    };

    function trueFunction(x) {
      // x in [0,1]; map to show nonlinearity to illustrate over/under-fit
      return Math.sin(2*Math.PI*x) + 0.3*x; // smooth, periodic + linear trend
    }

    function genData(seed) {
      state.seed = seed;
      const rng = mulberry32(seed >>> 0);
      const nTrain = 30, nTest = 100, noiseSigma = 0.20;
      const xsTrain = Array.from({length: nTrain}, () => rng()); // uniform [0,1)
      const xsTest  = Array.from({length: nTest }, () => rng());
      xsTrain.sort((a,b)=>a-b); xsTest.sort((a,b)=>a-b);
      const ysTrain = xsTrain.map(x => trueFunction(x) + randn(rng)*noiseSigma);
      const ysTest  = xsTest .map(x => trueFunction(x) + randn(rng)*noiseSigma);
      state.train = {x: xsTrain, y: ysTrain};
      state.test  = {x: xsTest , y: ysTest };
    }

    // ===== Scaling for numerical stability =====
    function scaleX(x) { // map [0,1] -> [-1,1]
      return x*2 - 1;
    }

    // ===== Model fitting =====
    function refit() {
      const d = state.degree;
      const X = state.train.x.map(x => polyFeatures(scaleX(x), d));
      const y = state.train.y.map(v => [v]);
      try {
        state.theta = fitNormalEq(X, y);
      } catch (e) {
        console.warn(e);
        state.theta = Array(d+1).fill(NaN);
      }
    }

    // ===== Drawing =====
    const canvas = document.getElementById('plot');
    const ctx = canvas.getContext('2d');

    const plot = {
      padding: {l: 56, r: 16, t: 16, b: 48},
      xMin: 0, xMax: 1,
      yMin: -1.8, yMax: 1.8,
    };

    function project(x, y) {
      const {l, r, t, b} = plot.padding;
      const W = canvas.width, H = canvas.height;
      const px = l + (W - l - r) * (x - plot.xMin) / (plot.xMax - plot.xMin);
      const py = H - b - (H - t - b) * (y - plot.yMin) / (plot.yMax - plot.yMin);
      return [px, py];
    }

    function drawGrid() {
      const {l, r, t, b} = plot.padding;
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);

      // background panel
      ctx.fillStyle = '#0a1024';
      ctx.fillRect(l, t, W - l - r, H - t - b);

      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
      ctx.lineWidth = 1;
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted');

      // y grid
      const yTicks = [-1.5,-1,-0.5,0,0.5,1,1.5];
      yTicks.forEach(y => {
        const [x0, yy] = project(plot.xMin, y);
        const [x1, _] = project(plot.xMax, y);
        ctx.beginPath(); ctx.moveTo(x0, yy); ctx.lineTo(x1, yy); ctx.stroke();
        ctx.fillText(y.toFixed(1), x0 - 28, yy + 4);
      });
      // x grid
      const xTicks = [0,0.2,0.4,0.6,0.8,1.0];
      xTicks.forEach(x => {
        const [xx, y0] = project(x, plot.yMin);
        const [_, y1] = project(x, plot.yMax);
        ctx.beginPath(); ctx.moveTo(xx, y0); ctx.lineTo(xx, y1); ctx.stroke();
        ctx.fillText(x.toFixed(1), xx - 8, y0 + 20);
      });

      // axes labels
      ctx.fillText('x', W - r - 10, H - b + 28);
      ctx.fillText('y', l - 20, t + 10);
    }

    function drawPoints(xs, ys, color, shape='circle') {
      ctx.fillStyle = color; ctx.strokeStyle = color; ctx.lineWidth = 1.5;
      for (let i=0;i<xs.length;i++) {
        const [px, py] = project(xs[i], ys[i]);
        if (shape === 'cross') {
          ctx.beginPath(); ctx.moveTo(px-4, py-4); ctx.lineTo(px+4, py+4); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(px+4, py-4); ctx.lineTo(px-4, py+4); ctx.stroke();
        } else {
          ctx.beginPath(); ctx.arc(px, py, 3.5, 0, Math.PI*2); ctx.fill();
        }
      }
    }

    function drawCurve(fn, color, width=2) {
      ctx.strokeStyle = color; ctx.lineWidth = width; ctx.beginPath();
      const N = 400; for (let i=0;i<=N;i++) {
        const x = i / N; const y = fn(x);
        const [px, py] = project(x, y);
        if (i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }

    function render() {
      drawGrid();

      // True function
      drawCurve(trueFunction, getComputedStyle(document.documentElement).getPropertyValue('--truth'), 1.5);

      // Training points
      drawPoints(state.train.x, state.train.y, getComputedStyle(document.documentElement).getPropertyValue('--train'), 'circle');

      // Learned model
      const d = state.degree;
      const theta = state.theta;
      drawCurve(x => predict(theta, scaleX(x)), getComputedStyle(document.documentElement).getPropertyValue('--curve'), 2.5);

      // Test points (conditionally)
      if (state.reveal) {
        drawPoints(state.test.x, state.test.y, getComputedStyle(document.documentElement).getPropertyValue('--test'), 'cross');
      }

      // Update stats
      const trainPred = state.train.x.map(x => predict(state.theta, scaleX(x)));
      const trainRMSE = rmse(state.train.y, trainPred);
      document.getElementById('rmseTrain').textContent = trainRMSE.toFixed(3);

      if (state.reveal) {
        const testPred = state.test.x.map(x => predict(state.theta, scaleX(x)));
        const testRMSE = rmse(state.test.y, testPred);
        document.getElementById('rmseTest').textContent = testRMSE.toFixed(3);
      } else {
        document.getElementById('rmseTest').textContent = 'Hidden';
      }

      document.getElementById('seedLabel').textContent = `seed: ${state.seed}`;
      document.getElementById('degVal').textContent = `${d}`;
    }

    // ===== Wiring =====
    const degreeEl = document.getElementById('degree');
    const revealBtn = document.getElementById('revealBtn');
    const regenBtn  = document.getElementById('regenBtn');

    degreeEl.addEventListener('input', () => {
      state.degree = parseInt(degreeEl.value, 10);
      refit();
      render();
    });

    revealBtn.addEventListener('click', () => {
      state.reveal = !state.reveal;
      revealBtn.textContent = state.reveal ? 'Hide Test Set' : 'Reveal Test Set';
      render();
    });

    regenBtn.addEventListener('click', () => {
      // Create a new random 32-bit seed
      const newSeed = (Math.random() * 0xFFFFFFFF) >>> 0;
      genData(newSeed);
      refit();
      render();
    });

    // ===== Init =====
    function init() {
      // initial seed from current time for variety; but deterministic thereafter until regen
      const seed = (Date.now() & 0xffffffff) >>> 0;
      genData(seed);
      refit();
      render();
      window.addEventListener('resize', () => { render(); });
    }
    init();
  </script>
</body>
</html>
